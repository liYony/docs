# 内核模块

## 1 内核模块简介

Linux提供了这样的机制，这种机制被称为模块(Module)模块具有这样的特点:

- 模块本身不被编译入内核映像，从而控制了内核的大小。
- 模块一旦被加载，它就和内核中的其他部分完全一样。

下面为一个最简单的Linux内核模块：

![image-20240112095927826](figures/image-20240112095927826.png)

包含以下内容：

- 内核模块的加载函数。
- 内核模块的卸载函数。
- 对GPL v2许可权限的声明。
- 描述信息。

| 命令       | 功能                                                         |
| ---------- | ------------------------------------------------------------ |
| insmod     | 加载模块。                                                   |
| rmmod      | 卸载模块。                                                   |
| lsmod      | 显示已经存在的模块，实际是读取分析`/proc/modules`文件。      |
| modprobe   | 加载模块，与insmod不同的是，该命令会同时加载目标模块依赖的其他模块。 |
| modprobe-r | 卸载模块，卸载模块的时候也会卸载其依赖的其他模块。           |
| modinfo    | 获取模块的信息，包括模块作者、说明、所支持的参数以及vermagic。 |

> 内核已经加载的模块信息存在于`sys/module`目录下。
>
> 模块之间的依赖关系存在于根文件系统的`lib/modules/<kernel-version>/modules.dep`文件中，该文件是在整体编译内核的时候由depmod工具生成的。
>
> ![image-20240112110740340](figures/image-20240112110740340.png)

## 2 内核模块程序结构

### 2.1 模块加载函数

当通过`insmod`或`modprobe`命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相关初始化工作。

### 2.2 模块的卸载函数

当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功能。

### 2.3 模块的许可声明

许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染（Kernel Tainted）的警告。

在Linux内核模块领域，可接受的LICENSE包括“GPL”、“GPL v2”、“GPL and additional rights”、“DualBSD/GPL”、“Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary”，这个在学术界和法律界都有争议）。

大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。

### 2.4 模块参数（可选）

模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。

### 2.5 模块导出符号（可选）

内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的变量或函数。

### 2.5 模块的作者信息（可选）

## 3 模块的加载函数

内核模块的加载函数一般以`__init`声明。

```c
static int __init initial_function(void)
{
    /* 模块初始化代码 */
    
    return 0;
}
module_init(initial_function);
```

> 模块加载函数以“module_init（函数名）”的形式被指定。它返回整型值，若初始化成功，应返回0。而在初始化失败时，应该返回错误编码。在Linux内核里，错误编码是一个接近于0的负值，在<linux/errno.h>中定义，包含-ENODEV、-ENOMEM之类的符号值。总是返回相应的错误编码是种非常好的习惯，因为只有这样，用户程序才可以利用perror等方法把它们转换成有意义的错误信息字符串。

在linux内核中，可以使用`request_module(const char *fmt, ...)`函数加载内核模块。这样子可以灵活的加载其他内核模块。

在linux内核中，所有标识为`__init`的函数如果直接编译进内核，都会成为内核镜像的一部分，在链接的时候都会放在`.init.text`这个段中。

```c
#define __init __attribute__ ((__section__ (".init.text")))
```

所有的`__init`函数在区段`.initcall.init`中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些`__init`函数，并在初始化完成后，释放`init`区段（包括.init.text、.initcall.init等）的内存。

除了函数以外，数据也可以被定义为__initdata，对于只是初始化阶段需要的数据，内核在初始化完后，也可以释放它们占用的内存。

```c
static int hello_data __initdata = 1;
```

## 4 模块的卸载函数

内核模块的加载函数一般以`__exit`声明。

```c
static void __exit cleanup_function(void)
{
    /* 模块卸载代码 */
}
module_exit(cleanup_function);
```

> 模块卸载函数在模块卸载的时候执行，而不返回任何值，且必须以“module_exit（函数名）”的形式来指定。通常来说，模块卸载函数要完成与模块加载函数相反的功能。

我们用`__exit`来修饰模块卸载函数，可以告诉内核如果相关的模块被直接编译进内核（即built-in），则`cleanup_function`函数会被省略，直接不链进最后的镜像。既然模块被内置了，就不可能卸载它了，卸载函数也就没有存在的必要了。除了函数以外，只是退出阶段采用的数据也可以用`__exitdata`来形容。

## 5 模块参数

```c
static char *book_name = "dissecting Linux Device Driver";
module_param(book_name, charp, S_IRUGO);
static int book_num = 4000;
module_param(book_num, int, S_IRUGO);
```

> 我们可以用“module_param（参数名，参数类型，参数读/写权限）”为模块定义一个参数，上面代码定义了1个整型参数和1个字符指针参数。

在装载内核模块时，用户可以向模块传递参数，形式为`insmode(或modprobe) 模块名 参数名=参数值`，如果不传递，参数将使用模块内定义的缺省值

如果模块被内置，就无法insmod了，但是bootloader可以通过在bootargs里设置`模块名 参数名=参数值`的形式给该内置的模块传递参数。

参数类型可以是byte、short、ushort、int、uint、long、ulong、charp（字符指针）、bool或invbool（布尔的反），在模块被编译时会将module_param中声明的类型与变量定义的类型进行比较，判断是否一致。

除此之外，模块也可以拥有参数数组，形式为“module_param_array（数组名，数组类型，数组长，参数读/写权限）”。

模块被加载后，在/sys/module/目录下将出现以此模块名命名的目录。当“参数读/写权限”为0时，表示此参数不存在sysfs文件系统下对应的文件节点，如果此模块存在“参数读/写权限”不为0的命令行参数，在此模块的目录下还将出现parameters目录，其中包含一系列以参数名命名的文件节点，这些文件的权限值就是传入module_param（）的“参数读/写权限”，而文件的内容为参数的值。

运行insmod或modprobe命令时，应使用逗号分隔输入的数组元素。

## 6 导出符号

Linux的`/proc/kallsyms`文件对应着内核符号表，它记录了符号以及符号所在的内存地址。

```c
EXPORT_SYMBOL(符号名);
EXPORT_SYMBOL_GPL(符号名);
```

## 7 模块的声明与描述

- MODULE_AUTHOR：模块作者。
- MODULE_DESCRIPTION：模块描述。
- MODULE_VERSION：模块版本。
- MODULE_DEVICE_TABLE：设备表。
- MODULE_ALIAS：模块别名。

> 注意：
>
> 对于USB、PCI等设备驱动，通常会建立一个MODULE_DEVICE_TABLE，以表明该驱动模块支持的设备。

## 8 模块的使用计数

Linux 2.4内核中，模块自身通过MOD_INC_USE_COUNT、MOD_DEC_USE_COUNT宏来管理自己被使用的计数。

Linux 2.6以后的内核提供了模块计数管理接口try_module_get（&module）和module_put（&module），从而取代Linux 2.4内核中的模块使用计数管理宏。模块的使用计数一般不必由模块自身管理，而且模块计数管理还考虑了SMP与PREEMPT机制的影响。

```c
// 用于增加模块使用计数；若返回为0，表示调用失败，希望使用的模块没有被加载或正在被卸载中。
int try_module_get(struct module *module);
// 该函数用于减少模块使用计数。
void module_put(struct module *module);
```

try_module_get（）和module_put（）的引入、使用与Linux 2.6以后的内核下的设备模型密切相关。Linux 2.6以后的内核为不同类型的设备定义了struct module*owner域，用来指向管理此设备的模块。当开始使用某个设备时，内核使用try_module_get（dev->owner）去增加管理此设备的owner模块的使用计数；当不再使用此设备时，内核使用module_put（dev->owner）减少对管理此设备的管理模块的使用计数。这样，当设备在使用时，管理此设备的模块将不能被卸载。只有当设备不再被使用时，模块才允许被卸载。

在Linux 2.6以后的内核下，对于设备驱动而言，很少需要亲自调用try_module_get（）与module_put（），因为此时开发人员所写的驱动通常为支持某具体设备的管理模块，对此设备owner模块的计数管理由内核里更底层的代码（如总线驱动或是此类设备共用的核心模块）来实现，从而简化了设备驱动开发。

## 9 模块的编译

```makefile
KVERS = $(shell uname -r)
# Kernel modules
obj-m += hello.o
# Specify flags for the module compilation.
#EXTRA_CFLAGS=-g -O0
build: kernel_modules
kernel_modules:
	make -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules
clean:
	make -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean
```

该Makefile文件应该与源代码hello.c位于同一目录，开启其中的EXTRA_CFLAGS=-g-O0，可以得到包含调试信息的hello.ko模块。运行make命令得到的模块可直接在PC上运行。如果一个模块包括多个.c文件（如file1.c、file2.c），则应该以如下方式编写Makefile：

```makefile
MODULE_NAME = modulename
obj-m := $(MODULE_NAME).o
$(MODULE_NAME)-objs := file1.o file2.o
```

## 10 使用模块“绕开”GPL

Linux内核有两种导出符号的方法给模块使用，一种方法是EXPORT_SYMBOL（），另外一种是EXPORT_SYMBOL_GPL（）。这一点和模块A导出符号给模块B用是一致的。

内核用EXPORT_SYMBOL_GPL（）导出的符号是不可以被非GPL模块引用的。

由于相当多的内核符号都是以EXPORT_SYMBOL_GPL（）导出的，所以历史上曾经有一些公司把内核的EXPORT_SYMBOL_GPL（）直接改为EXPORT_SYMBOL（），然后将修改后的内核以GPL形式发布。这样修改内核之后，模块不再使用内核的EXPORT_SYMBOL_GPL（）符号，因此模块不再需要GPL。对此Linus的回复是：“I think both them said that anybody who were to change a xyz_GPL to the non-GPLone in order to use it with a non-GPL module would almost immediately fall under the“willful infringement”thing，and that it would make it MUCH easier to get triple damages and/or injunctions，since they clearly knew aboutit”。因此，这种做法可能构成“蓄意侵权（willful infringement）”。另外一种做法是写一个wrapper内核模块（这个模块遵循GPL），把EXPORT_SYMBOL_GPL（）导出的符号封装一次后再以EXPORT_SYMBOL（）形式导出，而其他的模块不直接调用内核而是调用wrapper函数。

![image-20240112134610528](figures/image-20240112134610528.png)

一般认为，保守的做法是Linux内核不能使用非GPL许可权。
