# 字符设备驱动

## 1 字符设备驱动结构

### 1.1 cdev结构体

在Linux内核中，使用cdev结构体描述一个字符设备。

```c
struct cdev {
    struct kobject kobj;            /* 内嵌的kobject对象 */
    struct module *owner;           /* 所属模块*/
    struct file_operations *ops;    /* 文件操作结构体*/
    struct list_head list;
    dev_t dev;                      /* 设备号*/
    unsigned int count;
};
```

cdev结构体的dev_t成员定义了设备号，为32位，其中12位为主设备号，20位为次设备号。

```c
MAJOR(dev_t dev)            // 获取主设备号
MINOR(dev_t dev)            // 获取次设备号
MKDEV(int major, int minor) // 生成设备号
```

cdev结构体的另一个重要成员`file_operations`定义了字符设备驱动提供给虚拟文件系统的接口函数。

Linux内核提供了一组函数以用于操作cdev结构体：

使用cdev_init函数初始化cdev的成员，并建立cdev和file_operations之间的连接。

```c
void cdev_init(struct cdev *cdev, struct file_operations *fops);
```

| **参数** | **描述**                 |
| -------- | ------------------------ |
| cdev     | 定义的cdev结构体变量     |
| fops     | 字符设备文件操作函数集合 |
| **返回** | 无                       |

使用cdev_alloc函数动态申请一个cdev内存。

```c
struct cdev *cdev_alloc(void)
```

| **参数** | 无                     |
| -------- | ---------------------- |
| **返回** | ——                     |
| cdev     | 分配成功，返回cdev句柄 |
| NULL     | 分配失败               |

使用cdev_add函数向Linux系统添加字符设备(cdev结构体变量)，首先使用`cdev_init`函数完成对cdev结构体变量的初始化，然后使用`cdev_add`函数向Linux系统添加这个字符设备。

```c
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
```

| **参数** | **描述**                              |
| -------- | ------------------------------------- |
| p        | 指向要添加的字符设备(cdev 结构体变量) |
| dev      | 设备所使用的设备号                    |
| count    | 要添加的设备数量                      |
| **返回** | ——                                    |
| 0        | 添加设备成功                          |
| 负值     | 添加设备失败                          |

使用cdev_del函数向Linux系统卸载字符设备(cdev结构体变量)。

```c
void cdev_del(struct cdev *p)
```

| **参数** | **描述**                              |
| -------- | ------------------------------------- |
| p        | 指向要添加的字符设备(cdev 结构体变量) |
| **返回** | 无                                    |

### 1.2 分配和释放设备号

在调用cdev_add()函数向系统注册字符设备之前，应首先调用register_chrdev_region()或alloc_chrdev_region()函数向系统申请设备号。

```c
int register_chrdev_region(dev_t from, unsigned count, const char *name);
```

| **参数** | **描述**           |
| -------- | ------------------ |
| from     | 要申请的起始设备号 |
| count    | 申请设备号的数量   |
| name     | 设备名称           |
| **返回** | ——                 |
| 0        | 成功               |
| 负值     | 失败               |

```c
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);
```

| **参数**  | **描述**                                              |
| --------- | ----------------------------------------------------- |
| dev       | 指向 dev_t 类型变量的指针，该变量用于存储分配的设备号 |
| baseminor | 想要开始分配的次设备号的基数                          |
| count     | 申请设备号的数量                                      |
| name      | 设备名称                                              |
| **返回**  | ——                                                    |
| 0         | 成功                                                  |
| 负值      | 失败                                                  |

register_chrdev_region()函数用于已知起始设备的设备号的情况，而alloc_chrdev_region()用于设备号未知，向系统动态申请未被占用的设备号的情况，函数调用成功之后，会把得到的设备号放入第一个参数dev中。alloc_chrdev_region()相比于register_chrdev_region()的优点在于它会自动避开设备号重复的冲突。

相应地，在调用cdev_del()函数从系统注销字符设备之后，unregister_chrdev_region()应该被调用以释放原先申请的设备号，这个函数的原型为。

```c
void unregister_chrdev_region(dev_t from, unsigned count);
```

| **参数** | **描述**           |
| -------- | ------------------ |
| from     | 要卸载的起始设备号 |
| count    | 卸载设备号的数量   |
| **返回** | 无                 |

# 未完成