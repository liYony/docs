# 内核模块

## 1.1 内核模块的文件格式

以内核模块存在的驱动程序，比如demodev.ko，其在文件的数据组织形式上是ELF(Executable and Linkable Format)格式，更具体的，内核模块是一种普通的可重定向目标文件。

ELF是linux系统下非常重要的一种文件格式，常见的可执行程序都是以ELF的形式存在。ELF格式的结构图大致如下：

![image-20240109215103220](figures/image-20240109215103220.png)

- ELF header：大小为53字节，位于文件头部。

  - e_type：表明文件类型，对于驱动模块，这个值是1，也就是说驱动模块是一个可定位的ELF文件。
  - e_shoff：表明Section header table部分在文件中的偏移量。
  - e_shentsize：表明Section header table部分中每一个entry的大小(byte)。
  - e_shnum：表明Section header table中有多少个entry。因此，Section header table的大小为e_shentsize * e_shnum。
  - e_shstrndx：与Section header entry中的sh_name一起用来指定对应section的name。

- Section：ELF文件的主题，位于文件视图的中间部分的一块连续区域。但是当模块被内核加载的时候，会根据各自的属性被重新分配到新的内存区域(有点section也可能只起辅助作用，因此在运行的时候是不占实际的内存空间的)。

- Section header table：该部分位于文件视图的末尾，由若干个Section header entry组成。

  - sh_addr：这个值用来表示该entry所对应的section在内存中的实际地址。在静态的文件视图中，这个值为0，当模块被内核加载时，加载器会用该section在内存中的实际地址来改写sh_addr，如果section不占内存空间，该值为0。
  - sh_offset：表明section在文件视图中的偏移量。
  - sh_size：表明对应的section在文件视图中的大小(byte)，类型为SHT_NOBITS的section除外，这种section在文件视图中不占空间。
  - sh_entsize：主要用于由固定数量entry组成的表构成的section。如符号表，此情况下用来表示entry的大小。

## 2 EXPORT_SYMBOL的内核实现

如果没有独立存在的内核模块，作为单一的Linux内核映像，导出符号(EXPORT_SYMBOL)就失去了意义，对于静态编译链接而成的Linux内核映像来说，所有的符号引用都在静态链接阶段完成。然而，内核模块不可避免的要使用到内核提供的基础设施(以调用内核函数的形式发生)，作为独立编译链接的内核模块，必须要解决这种静态编译无法完成符号引用的问题(在内核模块所在的ELF文件中，这种引用被称为`未解决的引用`)，**处理`未解决的引用`问题的本质是在模块加载期间找到当前`未解决的引用`符号在内存中的实际地址**。

内核和内核模块通过`符号表`的形式向外部导出符号的相关信息。

![image-20240109223254092](figures/image-20240109223254092.png)

可见，由EXPORT_SYMBOL导出的符号，与一般变量没什么区别，只不过，这些符号被放在了特定的section中。上图中的`__kstrtab_my_exp_function`会被放在一个名为`__ksymtab_strings`的section中，`__ksymtab_my_exp_function`会放置在一个名为`__ksymtab`的section中(对于EXPORT_SYMBOL_GPL和EXPORT_SYMBOL_GPL_FUTRUE而言，struct kerner_symbol实例所在的section名称分别问`__ksymtab_gpl`和`__ksymtab_gpl_future`)。

对这些section的使用要经过一个中间环节，即链接脚本与链接器部分。链接脚本告诉链接器把所有目标文件中名为`__ksymtab`的section放置在最终内核(或者内核模块)映像文件的名为`__ksymtab`的section中(对于EXPORT_SYMBOL_GPL和EXPORT_SYMBOL_GPL_FUTRUE同理)。

![image-20240109224709174](figures/image-20240109224709174.png)

这里之所以要把所有向外界的符号放在一个特殊的section里面，是为了在加载其他模块时用来处理那些`未解决的引用`。注意这里由链接脚本定义的几个变量`__start___ksymtab`、`__stop___ksymtab`、`__start___ksymtab_gpl`、`__stop___ksymtab_gpl`、`__start___ksymtab_gpl_future`、`__stop___ksymtab_gpl_future`，它们会在对内核或者是某一内核模块的导出符号表进行查找时用到。内核源码中为使用这些连接器产生的变量做了如下声明：

![image-20240109225543259](figures/image-20240109225543259.png)

如此，内核代码便可以直接使用这些变量而不会引起编译错误。内核模块的加载器在处理模块`未解决的引用`的符号的时候，会使用到这里定义的这些变量。

## 3 模块的加载过程

在用户空间，用`insmod`这样的命令向内核空间安装一个内核模块。当调用`insmod demodev.ko`来安装demodev.ko这样的内核模块的时候，`insmod`首先会利用文件系统的接口将其数据读取到用户空间的一段内存，然后通过系统调用`sys_init_module`让内核去处理模块加载的整个过程。

为了更清楚的解释魔魁啊加载时的行为，这里把`sys_init_module`函数分为两个部分：

- 第一个部分是调用`load_module`函数，完成模块加载的最核心任务。
- 第二个部分是模块在被成功加载到系统之后的后续处理。

### 3.1 sys_init_module(第一部分)

![image-20240109234233473](figures/image-20240109234233473.png)

### 3.2 struct module

`load_module`函数的返回值是一个`struct module`类型的指针，该类型是内核用来管理系统中加载的模块时使用的一个非常重要的一个结构体。一个`struct module`对象代表着现实中一个内核模块在Linux系统中的抽象，定义如下：

![image-20240110000721492](figures/image-20240110000721492.png)

### 3.3 load_module

在这个函数内，我们除了可以了解到内核模块加载的幕后机制之外，还能了解到**内核模块如何调用内核代码导出的函数**，**被加载的模块如何向系统中的其他模块导出自己的符号**，以及**模块如何接收外部的参数**等。

