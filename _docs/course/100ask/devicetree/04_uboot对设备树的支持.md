# uboot对设备树的支持

## 1 传递dtb给内核

在uboot中，**启动内核**的命令是**bootm**。

在有设备树和无设备树时，bootm命令的使用是不同的。

- bootm <uImage_addr>                                                                 //无设备树
- bootm <uImage_addr> <initrd_addr> <dtb_addr>       //有设备树

比如，**没有使用设备树时**，通过指令将内核**uImage**读到内存0x3000 7FC0后，就可以使用bootm命令启动内核。

```shell
nand read.jffs2 0x30007FC0 kernel
bootm 0x30007FC0
```

**使用设备树时**，则还需要将dtb读到**内存**，假设读到起始地址为0x3200 0000的内存区域，然后再使用bootm命令启动内核，启动内核的时候，还要将**dtb在内存中的起始地址**也当做参数写入。

```shell
nand read.jffs2 0x30007FC0 kernel
nand read.jffs2 0x32000000 device_tree
bootm 0x30007FC0 - 0x32000000
```

需要注意的是，此时中间的参数代表的是**<initrd_addr>**，**内存文件系统的地址**。

当没有使用内存文件系统时，可以将它简写为一个**减号(-)**。

uboot使用bootm命令启动，那么bootm命令要怎么把dtb_addr写入r2寄存器传给内核呢？

根据**ARM程序调用规则**（**ATPCS**），当一个函数被调用的时候，它的**第一个参数**使用**r0**寄存器来传递，**第二个参数**使用**r1**寄存器来传递，传参的数量超过一定值之后（一般来说，该值为**4**），才使用**栈**来传参。

实际上，是定义个一个函数指针**th_kernel**，指向**内核的入口地址**。

然后，执行 **th_kernel**(0, machine_id, 0x32000000); 即可（使用设备时，machine_id未使用到，可以随便设置）。

看一下代码，**bootm**命令最终会调用到**do_bootm_linux**函数(\u-boot-1.1.6\lib_arm\armlinux.c）。

在**do_bootm_linux**函数中，会定义一个函数指针**theKernel**，它指向**内核的入口地址**。

![image-20240221220046284](figures/image-20240221220046284.png)

函数的简单分析如下，最终**通过theKernel调用函数启动内核**。

![image-20240221220116760](figures/image-20240221220116760.png)

**dtb可以随便存放在内核的任意区域吗？**

**不可以**，需要遵循**两个原则**：

- 不要破坏uboot本身（dtb放到内存时，uboot还在运行，当然不能被破坏）；
- 不要和内核使用的内存空间重合（dtb是给内核使用的，当然也不能破坏内核）：
  - 内核本身的空间不能占用；
  - 内核要用到的内存区域也不能占用；（内核启动时一般会在它所处位置的下边放置页表, 这块空间(一般是0x4000即16K字节)不能被占用）

JZ2440内存使用情况：

```
                     ------------------------------
  0x33f80000       ->|    u-boot                  |
                     ------------------------------
                     |    u-boot所使用的内存(栈等)|
                     ------------------------------
                     |                            |
                     |                            |
                     |        空闲区域             |
                     |                            |
                     |                            |
                     |                            |
                     |                            |
                     ------------------------------
  0x30008000       ->|      zImage                |
                     ------------------------------  uImage = 64字节的头部+zImage
  0x30007FC0       ->|      uImage头部            |
                     ------------------------------
  0x30004000       ->|      内核创建的页表         |  head.S
                     ------------------------------
                     |                            |
                     |                            |
              -----> ------------------------------
              |
              |
              --- (内存基址 0x30000000)
```

其中，**内核的加载地址**可以通过**mkimage**工具来读取。

![image-20240221220417527](figures/image-20240221220417527.png)

根据JZ2440内存使用情况，可以将**dtb**放到中间的**空闲区域**，或者0x30000000-0x30004000的空闲区域，只要不会影响到uboot和内核的运行即可。

另外，在内核启动之后，**dtb所在的内存区域会被保留**，不会有其他程序来使用这块内存区域，即不会有内存泄漏发生。

## 2 dtb的修改原理

